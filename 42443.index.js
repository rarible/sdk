"use strict";(self.webpackChunkexample=self.webpackChunkexample||[]).push([[42443],{42443:(t,e,a)=>{a.r(e),a.d(e,{connectSmartWallet:()=>F,disconnectSmartWallet:()=>V,isSmartWallet:()=>B,personalAccountToSmartAccountMap:()=>$});var n=a(42558),r=a(12506),s=a(27990),i=a(63117),o=a(29114),c=a(47981);function d(t={}){return(0,c.m)({signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",filters:t})}var u=a(99280),p=a(27238),l=a(41625),m=a(30666),y=a(75385);const h=()=>{const t=BigInt(Math.floor(4294967296*Math.random())),e=BigInt(Math.floor(4294967296*Math.random())),a=BigInt(Math.floor(4294967296*Math.random())),n=BigInt(Math.floor(4294967296*Math.random())),r=BigInt(Math.floor(4294967296*Math.random())),s=BigInt(Math.floor(4294967296*Math.random()));return t<<BigInt(160)|e<<BigInt(128)|a<<BigInt(96)|n<<BigInt(64)|r<<BigInt(32)|s},f=()=>BigInt((0,m.xW)([(0,u.cK)(h()),"0x0000000000000000"]));function g(t){return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,(0,y.q)(e)?e:(0,u.nj)(e)])))}var w=a(4364);async function v(t){const e=await A({...t,operation:"eth_estimateUserOperationGas",params:[g(t.userOp),t.options.overrides?.entrypointAddress??l.uh]});return{preVerificationGas:(0,u.uU)(e.preVerificationGas),verificationGas:(0,u.uU)(e.verificationGas),verificationGasLimit:(0,u.uU)(e.verificationGasLimit),callGasLimit:(0,u.uU)(e.callGasLimit)+l.L8}}async function G(t){const e=await A({...t,operation:"eth_getUserOperationReceipt",params:[t.userOpHash]});if(e){if(!1===e.success){const t=(0,o.p)({events:[d()],logs:e.logs}),a=t[0]?.args?.revertReason;if(!a)throw new Error(`UserOp failed at txHash: ${e.transactionHash}`);const n=(0,i.W)({data:a});throw new Error(`UserOp failed with reason: '${n.args.join(",")}' at txHash: ${e.transactionHash}`)}return e.receipt}}async function A(t){const{options:e,operation:a,params:n}=t;l.Oi&&w.debug(`>>> sending ${a} with payload:`,n);const r=e.overrides?.bundlerUrl??(0,l.RZ)(e.chain),s=(0,p.KI)(e.client),i=await s(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:a,params:n})}),o=await i.json();if(!i.ok||o.error){let t=o.error||i.statusText;"object"==typeof t&&(t=JSON.stringify(t));const e=o.code||"UNKNOWN";throw new Error(`${a} error: ${t}\nStatus: ${i.status}\nCode: ${e}`)}return l.Oi&&w.debug(`<<< ${a} result:`,o),o.result}var b=a(49255),x=a(18333),P=a(17371),O=a(20408),C=a(27956),L=a(11739),T=a(48412),D=a(92717),M=a(23903),U=a(4364);async function I(t){const{userOp:e,options:a}=t;if(a.overrides?.paymaster)return a.overrides?.paymaster(e);const n=a.client,r=(0,l.lI)(a.chain),s=a.overrides?.entrypointAddress??l.uh,i=(0,p.KI)(n),o=await i(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[g(e),s]})}),c=await o.json();if(!o.ok){const t=c.error||o.statusText,e=c.code||"UNKNOWN";throw new Error(`Paymaster error: ${t}\nStatus: ${o.status}\nCode: ${e}`)}if(l.Oi&&U.debug("Paymaster result:",c),c.result)return"string"==typeof c.result?{paymasterAndData:c.result}:{paymasterAndData:c.result.paymasterAndData,verificationGasLimit:c.result.verificationGasLimit?(0,u.uU)(c.result.verificationGasLimit):void 0,preVerificationGas:c.result.preVerificationGas?(0,u.uU)(c.result.preVerificationGas):void 0,callGasLimit:c.result.callGasLimit?(0,u.uU)(c.result.callGasLimit):void 0};const d=c.error?.message||c.error||o.statusText||"unknown error";throw new Error(`Paymaster error from ${r}: ${d}`)}var S=a(4364);function B(t){return"smart"===t.id}const $=new WeakMap,k=new WeakMap;async function F(t,e,i){const{personalAccount:o,client:c,chain:d}=e;if(!o)throw new Error("Personal wallet does not have an account");const p=i,m=p.factoryAddress??l.zk,y=d??p.chain,h=(0,r.P)({client:c,address:m,chain:y}),f=await async function(t,e){if(e.overrides?.predictAddress)return e.overrides.predictAddress(t);if(e.overrides?.accountAddress)return e.overrides.accountAddress;const a=e.personalAccountAddress;if(!a)throw new Error("Account address is required to predict the smart wallet address.");const n=(0,u.i3)(e.overrides?.accountSalt??"");return(0,x.readContract)({contract:t,method:"function getAddress(address, bytes) returns (address)",params:[a,n]})}(h,{personalAccountAddress:o.address,...p}).then((t=>t)).catch((()=>{throw new Error(`Failed to get account address with factory contract ${h.address} on chain ID ${y.id}. Are you on the right chain?`)})),g=(0,r.P)({client:c,address:f,chain:y}),w="gasless"in p?p.gasless:p.sponsorGas,v=await async function(t){const{accountContract:e}=t,r={address:e.address,async sendTransaction(a){const n=function(t){const{accountContract:e,options:a,transaction:n}=t;return a.overrides?.execute?a.overrides.execute(e,n):(0,b.m)({contract:e,method:"function execute(address, uint256, bytes)",params:[n.to||"",n.value||0n,n.data||"0x"]})}({accountContract:e,options:t,transaction:a});return H({executeTx:n,options:t})},async sendBatchTransaction(a){const n=function(t){const{accountContract:e,options:a,transactions:n}=t;return a.overrides?.executeBatch?a.overrides.executeBatch(e,n):(0,b.m)({contract:e,method:"function executeBatch(address[], uint256[], bytes[])",params:[n.map((t=>t.to||"")),n.map((t=>t.value||0n)),n.map((t=>t.data||"0x"))]})}({accountContract:e,options:t,transactions:a});return H({executeTx:n,options:t})},async signMessage({message:n}){const[{isContractDeployed:s},{readContract:i},{encodeAbiParameters:o},{hashMessage:c},{checkContractWalletSignature:d}]=await Promise.all([Promise.resolve().then(a.bind(a,11739)),Promise.resolve().then(a.bind(a,18333)),Promise.resolve().then(a.bind(a,27956)),Promise.resolve().then(a.bind(a,87381)),a.e(33501).then(a.bind(a,33501))]);await s(e)||(S.log("Account contract not deployed yet. Deploying account before signing message"),await E({options:t,account:r,accountContract:e}));const u=c(n);let p,l=!1;try{await i({contract:e,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[u]}),l=!0}catch(t){}if(l){const a=o([{type:"bytes32"}],[u]);p=await t.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:t.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:a}})}else p=await t.personalAccount.signMessage({message:n});if(await d({contract:e,message:n,signature:p}))return p;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")},async signTypedData(i){const o=(0,s.y)(i),[{isContractDeployed:c},{readContract:d},{encodeAbiParameters:u},{checkContractWalletSignedTypedData:p}]=await Promise.all([Promise.resolve().then(a.bind(a,11739)),Promise.resolve().then(a.bind(a,18333)),Promise.resolve().then(a.bind(a,27956)),a.e(58937).then(a.bind(a,58937))]);if(o.domain?.verifyingContract?.toLowerCase()===e.address?.toLowerCase())return t.personalAccount.signTypedData(o);await c(e)||(S.log("Account contract not deployed yet. Deploying account before signing message"),await E({options:t,account:r,accountContract:e}));const l=(0,n.Z)(o);let m,y=!1;try{await d({contract:e,method:"function getMessageHash(bytes32 _hash) public view returns (bytes32)",params:[l]}),y=!0}catch(t){}if(y){const a=u([{type:"bytes32"}],[l]);m=await t.personalAccount.signTypedData({domain:{name:"Account",version:"1",chainId:t.chain.id,verifyingContract:e.address},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]},message:{message:a}})}else m=await t.personalAccount.signTypedData(o);if(await p({contract:e,data:o,signature:m}))return m;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}};return r}({...p,chain:y,sponsorGas:w,personalAccount:o,accountContract:g,factoryContract:h,client:c});return $.set(o,t),k.set(t,o),[v,y]}async function V(t){const e=k.get(t);e&&($.delete(e),k.delete(t))}async function E(t){const{options:e,account:n,accountContract:r}=t,[{sendTransaction:s},{prepareTransaction:i}]=await Promise.all([a.e(13892).then(a.bind(a,13892)),Promise.resolve().then(a.bind(a,4558))]),o=i({client:e.client,chain:e.chain,to:r.address,value:0n});return await s({transaction:o,account:n})}async function H(t){const{executeTx:e,options:a}=t,n=await async function(t){const{executeTx:e,options:a}=t,n=await(0,L.isContractDeployed)(a.accountContract)?"0x":await async function(t){const{factoryContract:e}=t,a=function(t){const{factoryContract:e,options:a}=t;return a.overrides?.createAccount?a.overrides.createAccount(e):(0,b.m)({contract:e,method:"function createAccount(address, bytes) returns (address)",params:[a.personalAccount.address,(0,u.i3)(a.overrides?.accountSalt??"")]})}({factoryContract:e,options:t});return(0,m.xW)([e.address,await(0,O.encode)(a)])}(a),r=await(0,O.encode)(e);let{maxFeePerGas:s,maxPriorityFeePerGas:i}=e;const o=a.overrides?.bundlerUrl??(0,l.RZ)(a.chain);if((0,p.Lj)(o)){const t=await async function(t){const e=await A({...t,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxPriorityFeePerGas:(0,u.uU)(e.maxPriorityFeePerGas),maxFeePerGas:(0,u.uU)(e.maxFeePerGas)}}({options:a});s=t.maxFeePerGas,i=t.maxPriorityFeePerGas}else{const[t,e]=await Promise.all([(0,M.r)(s),(0,M.r)(i)]);if(t&&e)s=t,i=e;else{const n=await(0,P.G)(a.client,a.chain);i=e??n.maxPriorityFeePerGas??0n,s=t??n.maxFeePerGas??0n}}const c=f(),d={sender:a.accountContract.address,nonce:c,initCode:n,callData:r,maxFeePerGas:s,maxPriorityFeePerGas:i,callGasLimit:0n,verificationGasLimit:0n,preVerificationGas:0n,paymasterAndData:"0x",signature:l.km};if(a.sponsorGas){const t=await I({userOp:d,options:a}),e=t.paymasterAndData;if(e&&"0x"!==e&&(d.paymasterAndData=e),t.callGasLimit&&t.verificationGasLimit&&t.preVerificationGas)d.callGasLimit=t.callGasLimit,d.verificationGasLimit=t.verificationGasLimit,d.preVerificationGas=t.preVerificationGas;else{const t=await v({userOp:d,options:a});if(d.callGasLimit=t.callGasLimit,d.verificationGasLimit=t.verificationGasLimit,d.preVerificationGas=t.preVerificationGas,e&&"0x"!==e){const t=await I({userOp:d,options:a});t.paymasterAndData&&"0x"!==t.paymasterAndData&&(d.paymasterAndData=t.paymasterAndData)}}}else{const t=await v({userOp:d,options:a});d.callGasLimit=t.callGasLimit,d.verificationGasLimit=t.verificationGasLimit,d.preVerificationGas=t.preVerificationGas}return{...d,signature:"0x"}}({executeTx:e,options:a}),r=await async function(t){const{userOp:e,options:a}=t,n=function(t){const{userOp:e,entryPoint:a,chainId:n}=t,r=(0,D.S)(e.initCode),s=(0,D.S)(e.callData),i=(0,D.S)(e.paymasterAndData),o=(0,C.encodeAbiParameters)([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"uint256"},{type:"bytes32"}],[e.sender,e.nonce,r,s,e.callGasLimit,e.verificationGasLimit,e.preVerificationGas,e.maxFeePerGas,e.maxPriorityFeePerGas,i]),c=(0,C.encodeAbiParameters)([{type:"bytes32"},{type:"address"},{type:"uint256"}],[(0,D.S)(o),a,BigInt(n)]);return(0,D.S)(c)}({userOp:e,entryPoint:a.overrides?.entrypointAddress||l.uh,chainId:a.chain.id});if(a.personalAccount.signMessage){const t=await a.personalAccount.signMessage({message:{raw:(0,T.aT)(n)}});return{...e,signature:t}}throw new Error("signMessage not implemented in signingAccount")}({options:a,userOp:n}),s=await async function(t){return A({...t,operation:"eth_sendUserOperation",params:[g(t.userOp),t.options.overrides?.entrypointAddress??l.uh]})}({options:a,userOp:r}),i=await async function(t){const{options:e,userOpHash:a}=t,n=Date.now()+12e4;for(;Date.now()<n;){const t=await G({options:e,userOpHash:a});if(t)return t;await new Promise((t=>setTimeout(t,1e3)))}throw new Error("Timeout waiting for userOp to be mined")}({options:a,userOpHash:s});return{client:a.client,chain:a.chain,transactionHash:i.transactionHash}}}}]);