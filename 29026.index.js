"use strict";(self.webpackChunkexample=self.webpackChunkexample||[]).push([[29026],{53255:(e,t,n)=>{n.d(t,{D:()=>s});var a=n(99280);async function s(e){const t=await e({method:"eth_blockNumber"});return(0,a.uU)(t)}},23058:(e,t,n)=>{n.d(t,{l:()=>i});var a=n(79756),s=n(6577),r=n(39571);const o={"0x0":"reverted","0x1":"success"};async function i(e,t){const n=await e({method:"eth_getTransactionReceipt",params:[t.hash]});if(!n)throw new Error("Transaction receipt not found.");return function(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map((e=>(0,s.e)(e))):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?(0,a.ME)(e.transactionIndex):null,status:e.status?o[e.status]:null,type:e.type?r.b4[e.type]||e.type:null};return e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed)),t}(n)}},75450:(e,t,n)=>{n.d(t,{q:()=>m});var a=n(53255),s=n(36223);const r=5e3,o=1e3,i=500,c=2,l=10;function u(e,t,n){let u,d,m=[],h=[],f=!1;const w=(0,s.getRpcClient)({client:e,chain:t});async function g(){if(!f)return;const e=await(0,a.D)(w);if(!u||e>u){let t=[];if(u)for(let n=u+1n;n<=e;n++)t.push(BigInt(n));else t=[e];u=e;const n=(new Date).getTime();if(d){const e=(n-d)/t.length;h.push(e),h=h.slice(-l)}d=n;for(const e of t)for(const t of m)t(e)}const t=function(e){for(;e.length<l;)e.unshift(o);return e.reduce(((e,t)=>e+t),0)/e.length}(h),s=Math.max(i,Math.min(r,Math.max(i,t)));var p;await(p=s/(n??c),new Promise((e=>setTimeout(e,p)))),g()}return function(e,t){return m.push(e),f||(u=t,f=!0,g()),function(){m=m.filter((t=>t!==e)),0===m.length&&(u=void 0,d=void 0,f=!1)}}}const d=new Map;function m(e){const{client:t,chain:n,onNewBlockNumber:a,overPollRatio:s,latestBlockNumber:r}=e,o=n.id;let i=d.get(o);return i||(i=u(t,n,s),d.set(o,i)),i(a,r)}},29026:(e,t,n)=>{n.d(t,{relayEngineTransaction:()=>l});var a=n(12506),s=n(72559),r=n(18333),o=n(50099);const i=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],c=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function l(e){const{message:t,messageType:n,signature:o}=await async function({account:e,serializableTransaction:t,transaction:n,gasless:s}){const o=(0,a.P)({address:s.relayerForwarderAddress,chain:n.chain,client:n.client}),l=await(0,r.readContract)({contract:o,method:"function getNonce(address) view returns (uint256)",params:[e.address]}),[u,d]=await(async()=>{if(!t.to)throw new Error("engine transactions must have a 'to' address");if(!t.gas)throw new Error("engine transactions must have a 'gas' value");if(!t.data)throw new Error("engine transactions must have a 'data' value");if(s.experimentalChainlessSupport){const a={from:e.address,to:t.to,value:0n,gas:t.gas,nonce:l,data:t.data,chainid:BigInt(n.chain.id)};return[await e.signTypedData({domain:{name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:o.address},message:a,primaryType:"ForwardRequest",types:{ForwardRequest:c}}),a]}const a={from:e.address,to:t.to,value:0n,gas:t.gas,nonce:l,data:t.data};return[await e.signTypedData({domain:{name:s.domainName??"GSNv2 Forwarder",version:s.domainVersion??"0.0.1",chainId:n.chain.id,verifyingContract:o.address},message:a,primaryType:"ForwardRequest",types:{ForwardRequest:i}}),a]})();return{message:d,signature:u,messageType:"forward"}}(e),l=await fetch(e.gasless.relayerUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:(0,s.A)({request:t,type:n,signature:o,forwarderAddress:e.gasless.relayerForwarderAddress})});if(!l.ok)throw new Error(`Failed to send transaction: ${await l.text()}`);const d=await l.json();if(!d.result)throw new Error(`Relay transaction failed: ${d.message}`);const m=d.result.queueId,h=Date.now()+6e4;for(;Date.now()<h;){const t=await u({options:e,queueId:m});if(t)return{transactionHash:t.transactionHash,chain:e.transaction.chain,client:e.transaction.client};await new Promise((e=>setTimeout(e,1e3)))}throw new Error("Failed to find relayed transaction after 60000ms")}async function u(e){const{options:t,queueId:n}=e,a=t.gasless.relayerUrl.split("/relayer/")[0],s=await fetch(`${a}/transaction/status/${n}`,{method:"GET"}),r=await s.json();if(!s.ok)return null;const i=r.result;if(!i)return null;switch(i.status){case"errored":throw new Error(`Transaction errored with reason: ${i.errorMessage}`);case"cancelled":throw new Error("Transaction execution cancelled.");case"mined":return await(0,o.L)({client:t.transaction.client,chain:t.transaction.chain,transactionHash:i.transactionHash});default:return null}}},50099:(e,t,n)=>{n.d(t,{L:()=>c});var a=n(23058),s=n(36223),r=n(75450);const o=30,i=new Map;function c(e){const{transactionHash:t,chain:n,client:c}=e,l=`${n.id}:tx_${t}`,u=e.maxBlocksWaitTime??o;if(i.has(l))return i.get(l);const d=new Promise(((e,o)=>{t||o(new Error("Transaction has no transactionHash to wait for, did you execute it?"));const i=(0,s.getRpcClient)({client:c,chain:n});let l=-1;const d=(0,r.q)({client:c,chain:n,onNewBlockNumber:async()=>{if(l++,l>=u)return d(),void o(new Error(`Transaction not found after ${u} blocks`));try{const n=await(0,a.l)(i,{hash:t});d(),e(n)}catch{}}})})).finally((()=>{i.delete(l)}));return i.set(l,d),d}},6577:(e,t,n)=>{function a(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}n.d(t,{e:()=>a})}}]);